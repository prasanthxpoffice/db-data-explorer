<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>db-data-explorer · Graph Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Cytoscape -->
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <link rel="stylesheet" href="css/styles.css" />
    <style>
      /* Small inline tweaks for list buttons */
      #seed-list button {
        font-size: 11px;
        padding: 2px 6px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="panel">
        <h1>db-data-explorer</h1>

        <div>
          <label>API</label>
          <div class="hint">
            <span class="tag">POST /api/traverseStepMulti</span>
          </div>
        </div>

        <div>
          <label>Filters</label>
          <div class="row">
            <div>
              <label>View IDs</label>
              <div class="multiselect" id="view-select">
                <button id="view-dropdown-btn" type="button">
                  Selected: 1,2
                </button>
                <div class="multiselect-menu" id="view-dropdown"></div>
              </div>
            </div>
            <div>
              <label>Depth</label>
              <input id="depth" type="number" min="1" step="1" value="1" />
            </div>
          </div>
          <div class="row">
            <div>
              <label>Max Fanout (optional)</label>
              <input
                id="maxFanout"
                type="number"
                min="1"
                step="1"
                value="200"
              />
            </div>
            <div></div>
          </div>
          <div class="row">
            <div>
              <label>Language</label>
              <select id="lang">
                <option value="en" selected>English</option>
                <option value="ar">Arabic</option>
              </select>
            </div>
            <div>
              <label>Layout</label>
              <select id="layout">
                <option value="cose" selected>cose</option>
                <option value="breadthfirst">breadthfirst</option>
                <option value="concentric">concentric</option>
                <option value="grid">grid</option>
              </select>
            </div>
            <div style="display:flex; align-items:flex-end; gap:6px;">
              <label style="margin:0 6px 0 12px;">Animate</label>
              <input id="animate" type="checkbox" checked />
            </div>
          </div>

          <div>
            <label>Seeds (Frontier)</label>
            <div class="row">
              <input
                id="seed-col"
                type="text"
                placeholder="Column (e.g. ID_AID)"
              />
              <input id="seed-val" type="text" placeholder="Value (e.g. 1)" />
            </div>
            <div class="btns" style="margin-top: 8px">
              <button id="add-seed" type="button">Add Seed</button>
              <button id="clear-seeds" type="button">Clear Seeds</button>
            </div>
            <div class="hint">
              Seeds are <code>{ col, val }</code> pairs. Example: col
              <code>ID_AID</code>, val <code>1</code>.
            </div>
            <ul
              id="seed-list"
              style="list-style: none; padding-left: 0; margin-top: 8px"
            ></ul>
          </div>

          <div class="btns">
            <button id="run">Run Step</button>
            <button id="clear">Clear Graph</button>
          </div>
          <div class="hint">
            Tip: select a node in the graph to auto-expand.
          </div>
        </div>

        <div id="details-panel" style="margin-top: 14px">
          <label>Selection</label>
          <div id="node-details" class="hint">No node selected.</div>
        </div>
      </div>

      <div id="cy"></div>
    </div>

    <script>
      // ---------- Graph setup ----------
      // Base URL for API calls. If opened via file://, default to localhost:3000.
      const apiBase =
        location.protocol === "file:" ? "http://localhost:3000" : "";
      const cy = cytoscape({
        container: document.getElementById("cy"),
        style: [
          {
            selector: "node",
            style: {
              label: "data(label)",
              "text-wrap": "wrap",
              "text-max-width": 120,
              "font-size": 12,
              "background-color": (ele) => ele.data("color") || "#64748b",
              "border-width": 1,
              "border-color": "#0f172a",
              width: "label",
              height: "label",
              padding: "10px",
              shape: "round-rectangle",
              "text-valign": "center",
              "text-halign": "center",
              color: "#e5e7eb",
            },
          },
          {
            selector: "edge",
            style: {
              width: 2,
              "line-color": "#475569",
              "target-arrow-color": "#475569",
              "target-arrow-shape": "triangle",
              "curve-style": "bezier",
            },
          },
          // If an edge is marked bidirectional, show arrowheads on both ends
          {
            selector: "edge[bidirectional]",
            style: { "source-arrow-shape": "triangle" },
          },
          {
            selector: ":selected",
            style: { "border-width": 2, "border-color": "#f59e0b" },
          },
          {
            selector: "node.sp",
            style: { "border-width": 3, "border-color": "#06b6d4" },
          },
          {
            selector: "node.sp-start",
            style: {
              "border-width": 4,
              "border-color": "#22c55e",
              "background-image": "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='%2322c55e'><path d='M5 3v18'/><path d='M7 4h10l-2 3 2 3H7z'/></svg>",
              "background-fit": "none",
              "background-width": 16,
              "background-height": 16,
              "background-position-x": 4,
              "background-position-y": 4,
              "background-repeat": "no-repeat",
            },
          },
          {
            selector: "node.sp-end",
            style: {
              "border-width": 4,
              "border-color": "#ef4444",
              "background-image": "data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='%23ef4444'><path d='M12 2l4 4-4 4-4-4 4-4z'/><circle cx='12' cy='18' r='3'/></svg>",
              "background-fit": "none",
              "background-width": 16,
              "background-height": 16,
              "background-position-x": 4,
              "background-position-y": 4,
              "background-repeat": "no-repeat",
            },
          },
          {
            selector: "edge.sp",
            style: {
              width: 4,
              "line-color": "#f59e0b",
              "target-arrow-color": "#f59e0b",
              "source-arrow-color": "#f59e0b",
              "curve-style": "bezier",
              "target-arrow-shape": "none",
              "source-arrow-shape": "none",
              "arrow-scale": 1.4,
            },
          },
          {
            selector: "edge.sp.sp-blinkA",
            style: { opacity: 1 },
          },
          {
            selector: "edge.sp.sp-blinkB",
            style: { opacity: 0.25 },
          },
          {
            selector: "edge.sp[spDir = 'forward']",
            style: {
              "target-arrow-shape": "triangle",
              "source-arrow-shape": "none",
            },
          },
          {
            selector: "edge.sp[spDir = 'reverse']",
            style: {
              "source-arrow-shape": "triangle",
              "target-arrow-shape": "none",
            },
          },
        ],
        layout: { name: document.getElementById("layout").value },
        wheelSensitivity: 0.15,
      });

      // ---------- Helpers ----------
      function nodeId(col, val) {
        return `${col}:${val}`;
      }
      function edgeId(from_col, from_val, to_col, to_val) {
        return `${from_col}:${from_val}->${to_col}:${to_val}`;
      }

      function ensureNode({ col, val, text, color, type }) {
        const id = nodeId(col, val);
        if (!cy.getElementById(id).empty()) return cy.getElementById(id);
        const label = text || String(val);
        return cy.add({
          group: "nodes",
          data: { id, col, val, label, color, type },
        });
      }

      // Collapse reverse edges into one "bidirectional" edge in the UI
      function ensureEdge(row) {
        const source = nodeId(row.from_col, row.from_val);
        const target = nodeId(row.to_col, row.to_val);

        // Ensure endpoint nodes exist (with supplied labels/colors)
        ensureNode({
          col: row.from_col,
          val: row.from_val,
          text: row.from_text,
          color: row.from_color,
          type: row.from_type,
        });
        ensureNode({
          col: row.to_col,
          val: row.to_val,
          text: row.to_text,
          color: row.to_color,
          type: row.to_type,
        });

        const id = edgeId(row.from_col, row.from_val, row.to_col, row.to_val);
        const revId = edgeId(
          row.to_col,
          row.to_val,
          row.from_col,
          row.from_val
        );

        // if this exact edge exists, return it
        let e = cy.getElementById(id);
        if (!e.empty()) return e;

        // if reverse edge exists, upgrade it to bidirectional
        const rev = cy.getElementById(revId);
        if (!rev.empty()) {
          rev.data("bidirectional", true);
          return rev;
        }

        // otherwise create a normal directed edge
        return cy.add({ group: "edges", data: { id, source, target } });
      }

      // ---------- Perf helpers ----------
      let layoutTimer = null;
      function relayout() {
        clearTimeout(layoutTimer);
        const name = document.getElementById("layout").value;
        layoutTimer = setTimeout(() => {
          cy.layout({ name, animate: isAnimate(), fit: true, padding: 20 }).run();
        }, 50); // debounce a bit
      }
      document.getElementById("layout").addEventListener("change", relayout);

      function setEdgeStyleForSize() {
        const many = cy.edges().length > 1000;
        cy.style()
          .selector("edge")
          .style({
            width: 2,
            "curve-style": many ? "haystack" : "bezier",
            "target-arrow-shape": many ? "none" : "triangle",
            "line-color": "#475569",
            "target-arrow-color": "#475569",
          })
          .selector("edge[bidirectional]")
          .style({ "source-arrow-shape": many ? "none" : "triangle" })
          // Re-apply strong override for highlighted shortest-path edges
          .selector("edge.sp")
          .style({
            width: 4,
            "curve-style": "bezier",
            "line-color": "#f59e0b",
            "target-arrow-color": "#f59e0b",
            "source-arrow-color": "#f59e0b",
            "target-arrow-shape": "none",
            "source-arrow-shape": "none",
            "arrow-scale": 1.4,
          })
          .selector("edge.sp.sp-blinkA").style({ opacity: 1 })
          .selector("edge.sp.sp-blinkB").style({ opacity: 0.25 })
          .selector("edge.sp[spDir = 'forward']").style({ "target-arrow-shape": "triangle", "source-arrow-shape": "none" })
          .selector("edge.sp[spDir = 'reverse']").style({ "source-arrow-shape": "triangle", "target-arrow-shape": "none" })
          .update();
      }

      function adjustLabels() {
        const many = cy.nodes().length > 1500;
        cy.style()
          .selector("node")
          .style({
            label: many ? "" : "data(label)",
            "min-zoomed-font-size": many ? 8 : 0,
          })
          .update();
      }

      // ---------- State maintained in the page ----------
      let currentFrontier = [];
      let perViewExclude = [];
      let perViewExcludeSet = new Set();
      function addExclude(viewId, col, val) {
        const key = `${viewId}|${col}|${String(val)}`;
        if (perViewExcludeSet.has(key)) return;
        perViewExcludeSet.add(key);
        perViewExclude.push({ ViewID: viewId, col, val: String(val) });
      }
      let seeds = [];

      // Shortest path state
      let pathStartId = null;
      let pathEndId = null;
      let currentPathEles = null;
      let pathTimers = [];
      let pathBlinkInterval = null;

      function renderEdges(rows, options = {}) {
        cy.batch(() => {
          rows.forEach(ensureEdge);
        }); // batch DOM ops
        relayout();
      }

      function renderSeedList() {
        const ul = document.getElementById("seed-list");
        ul.innerHTML = "";
        seeds.forEach((s, idx) => {
          const li = document.createElement("li");
          li.className = "hint";
          li.style.margin = "2px 0";
          li.textContent = `${s.col} = ${s.val}`;
          const btn = document.createElement("button");
          btn.textContent = "Remove";
          btn.style.marginLeft = "8px";
          btn.addEventListener("click", () => {
            seeds.splice(idx, 1);
            renderSeedList();
          });
          li.appendChild(btn);
          ul.appendChild(li);
        });
      }

      document.getElementById("add-seed").addEventListener("click", () => {
        const col = (document.getElementById("seed-col").value || "").trim();
        const val = (document.getElementById("seed-val").value || "").trim();
        if (!col || !val) {
          alert("Enter both Column and Value.");
          return;
        }
        seeds.push({ col, val });
        document.getElementById("seed-col").value = "";
        document.getElementById("seed-val").value = "";
        renderSeedList();
      });

      document.getElementById("clear-seeds").addEventListener("click", () => {
        seeds = [];
        renderSeedList();
      });

      function buildPayloadFromUI() {
        const viewIds = getSelectedViewIds();
        const depth = Math.max(
          1,
          parseInt(document.getElementById("depth").value || "1", 10)
        );
        const lang = document.getElementById("lang").value;
        const maxFanoutText = document.getElementById("maxFanout").value;
        const maxFanout = maxFanoutText
          ? parseInt(maxFanoutText, 10)
          : undefined;
        return {
          viewIds,
          frontier: seeds.slice(),
          perViewExclude,
          depth,
          lang,
          maxFanout,
        };
      }

      // ---------- API call ----------
      async function apiStep(body) {
        const res = await fetch(`${apiBase}/api/traverseStepMulti`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        if (!res.ok) throw new Error(`API ${res.status} ${await res.text()}`);
        return res.json(); // { edges, nextFrontier }
      }

      // ---------- Button handlers ----------
      document.getElementById("run").addEventListener("click", async () => {
        const payload = buildPayloadFromUI();
        try {
          let steps = Math.max(1, parseInt(String(payload.depth || 1), 10));
          let next = seeds.slice();
          if (!next.length && cy.nodes().length) {
            // If no seeds specified but graph has nodes, use currently selected or all nodes as frontier
            const sel = cy.nodes(":selected");
            const pool = sel.length ? sel : cy.nodes();
            next = pool.map((n) => ({ col: n.data("col"), val: String(n.data("val")) }));
          }

          for (let d = 0; d < steps; d++) {
            if (!next || next.length === 0) break;
            payload.frontier = next.slice();
            payload.depth = 1; // advance exactly one step per call
            payload.perViewExclude = perViewExclude;
            const { edges, nextFrontier } = await apiStep(payload);
            renderEdges(edges || []);
            setEdgeStyleForSize();
            adjustLabels();

            currentFrontier = (nextFrontier || []).slice();

            if (Array.isArray(payload.viewIds)) {
              for (const v of payload.viewIds) {
                for (const f of currentFrontier) addExclude(v, f.col, f.val);
              }
            }

            next = currentFrontier;
          }
        } catch (err) {
          console.error(err);
          alert(err.message);
        }
      });

      let isExpanding = false;
      async function expandFromNode(n) {
        if (!n || isExpanding) return;
        isExpanding = true;
        const payload = buildPayloadFromUI();
        try {
          let steps = Math.max(1, parseInt(String(payload.depth || 1), 10));
          let next = [{ col: n.col, val: String(n.val) }];
          for (let d = 0; d < steps; d++) {
            if (!next || next.length === 0) break;
            payload.frontier = next.slice();
            payload.depth = 1; // advance exactly one step per call
            payload.perViewExclude = perViewExclude;
            const { edges, nextFrontier } = await apiStep(payload);
            renderEdges(edges || []);
            setEdgeStyleForSize();
            adjustLabels();

            currentFrontier = (nextFrontier || []).slice();
            if (Array.isArray(payload.viewIds)) {
              for (const v of payload.viewIds) {
                for (const f of currentFrontier) addExclude(v, f.col, f.val);
              }
            }
            next = currentFrontier;
          }
        } catch (err) {
          console.error(err);
          alert(err.message);
        } finally {
          isExpanding = false;
        }
      }

      cy.on("select", "node", async (evt) => {
        const n = evt.target.data();
        renderNodeDetails(n);
        await expandFromNode(n);
      });

      cy.on("unselect", "node", () => {
        // If nothing remains selected, clear the panel
        if (cy.nodes(":selected").length === 0) {
          document.getElementById("node-details").innerHTML = "No node selected.";
        }
      });

      document.getElementById("clear").addEventListener("click", () => {
        cy.elements().remove();
        currentFrontier = [];
        perViewExclude = [];
        perViewExcludeSet = new Set();
        seeds = [];
        renderSeedList();
        setEdgeStyleForSize();
        adjustLabels();
      });

      // ----- View IDs multiselect -----
      let availableViews = [];
      const viewSelected = new Set();
      const viewContainer = document.getElementById("view-select");
      const viewMenu = document.getElementById("view-dropdown");
      const viewBtn = document.getElementById("view-dropdown-btn");

      function updateViewButton() {
        const list = Array.from(viewSelected).sort((a, b) => a - b);
        viewBtn.textContent = list.length
          ? `Selected: ${list.join(",")}`
          : "Select views";
      }

      function renderViewMenu() {
        viewMenu.innerHTML = "";
        const lang = document.getElementById("lang").value || "en";
        availableViews.forEach((v) => {
          const label = document.createElement("label");
          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.value = String(v.id);
          cb.checked = viewSelected.has(v.id);
          cb.addEventListener("change", () => {
            if (cb.checked) viewSelected.add(v.id);
            else viewSelected.delete(v.id);
            updateViewButton();
          });
          const span = document.createElement("span");
          const labelText =
            lang === "ar"
              ? v.descriptionAr || v.nameAr || `View ${v.id}`
              : v.descriptionEn || v.nameEn || `View ${v.id}`;
          span.textContent = labelText;
          label.appendChild(cb);
          label.appendChild(span);
          viewMenu.appendChild(label);
        });
      }

      function getSelectedViewIds() {
        return Array.from(viewSelected).sort((a, b) => a - b);
      }

      viewBtn.addEventListener("click", () => {
        const open = viewContainer.classList.toggle("open");
        if (open) renderViewMenu();
      });

      document.addEventListener("click", (e) => {
        if (!viewContainer.contains(e.target)) {
          viewContainer.classList.remove("open");
        }
      });

      async function loadViews() {
        try {
          const res = await fetch(`${apiBase}/api/views`);
          if (!res.ok) throw new Error(`Views API ${res.status}`);
          const arr = await res.json();
          availableViews = Array.isArray(arr)
            ? arr.map((v) => ({
                id: v.id,
                nameEn: v.nameEn,
                nameAr: v.nameAr,
                descriptionEn: v.descriptionEn,
                descriptionAr: v.descriptionAr,
              }))
            : [];
          // Preselect the first two if nothing selected yet
          if (viewSelected.size === 0) {
            availableViews.slice(0, 2).forEach((v) => viewSelected.add(v.id));
          }
          updateViewButton();
          renderViewMenu();
        } catch (e) {
          console.error("Failed to load views:", e);
          // Fallback: keep empty list, user can still enter seeds and run (server will error if viewIds empty)
          updateViewButton();
        }
      }

      // Re-render menu labels when language changes
      document.getElementById("lang").addEventListener("change", () => {
        if (viewContainer.classList.contains("open")) renderViewMenu();
      });

      loadViews();
      updateViewButton();
      renderViewMenu();

      // Initialize filters UI
      renderSeedList();

      // -------- Node details renderer --------
      function renderNodeDetails(n) {
        const panel = document.getElementById("node-details");
        if (!n) {
          panel.textContent = "No node selected.";
          return;
        }
        const id = nodeId(n.col, n.val);
        const node = cy.getElementById(id);
        const deg = !node.empty() ? node.degree() : 0;
        const indeg = !node.empty() ? node.indegree() : 0;
        const outdeg = !node.empty() ? node.outdegree() : 0;

        const color = n.color || "#64748b";
        const type = n.type || "";
        const label = (n.label ?? "").toString();

        const html = `
          <div style="display:flex; align-items:center; gap:10px;">
            <div style="width:14px;height:14px;border-radius:3px;background:${color};border:1px solid #0f172a;"></div>
            <div style="font-weight:600;">${label || String(n.val)}</div>
          </div>
          <div style="margin-top:8px;">
            <div><span class="tag">Column</span> ${n.col}</div>
            <div><span class="tag">Value</span> ${String(n.val)}</div>
            ${type ? `<div><span class=\"tag\">Type</span> ${type}</div>` : ""}
            <div style="margin-top:6px;">
              <span class="tag">Degree</span> ${deg} (in ${indeg} | out ${outdeg})
            </div>
          </div>
          <div class="btns" style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
            <button id="copy-node-json" type="button">Copy JSON</button>
            <button id="set-start" type="button">Set Start</button>
            <button id="set-end" type="button">Set End</button>
            <button id="show-path" type="button" ${pathStartId && pathEndId ? '' : 'disabled'}>Show Shortest Path</button>
            <button id="clear-path" type="button" ${currentPathEles ? '' : 'disabled'}>Clear Path</button>
          </div>
          <div class="hint" style="margin-top:6px;">
            <span class="tag">Path Start</span> ${pathStartId ?? '—'}
            <span class="tag" style="margin-left:6px;">Path End</span> ${pathEndId ?? '—'}
          </div>
        `;
        panel.innerHTML = html;

        const btn = document.getElementById("copy-node-json");
        if (btn) {
          btn.addEventListener("click", async () => {
            const payload = {
              col: n.col,
              val: String(n.val),
              type: type || undefined,
              label: label,
              color: color,
              degree: { total: deg, in: indeg, out: outdeg },
            };
            try {
              await navigator.clipboard.writeText(JSON.stringify(payload, null, 2));
              btn.textContent = "Copied";
              setTimeout(() => (btn.textContent = "Copy JSON"), 1200);
            } catch {}
          });
        }

        const btnStart = document.getElementById("set-start");
        if (btnStart) btnStart.addEventListener("click", () => { pathStartId = id; renderNodeDetails(n); });
        const btnEnd = document.getElementById("set-end");
        if (btnEnd) btnEnd.addEventListener("click", () => { pathEndId = id; renderNodeDetails(n); });
        const btnShow = document.getElementById("show-path");
        if (btnShow) btnShow.addEventListener("click", () => { showShortestPath(); });
        const btnClear = document.getElementById("clear-path");
        if (btnClear) btnClear.addEventListener("click", () => { clearShortestPath(); renderNodeDetails(n); });
      }

      function clearShortestPath() {
        try { cy.stop(); } catch {}
        for (const t of pathTimers) clearTimeout(t);
        pathTimers = [];
        if (pathBlinkInterval) { try { clearInterval(pathBlinkInterval); } catch {} pathBlinkInterval = null; }
        // Remove highlight from any previously marked elements, even if collection reference lost
        cy.elements('.sp').removeClass('sp');
        cy.edges().removeClass('sp-blinkA sp-blinkB');
        if (pathStartId) cy.getElementById(pathStartId).removeClass('sp-start');
        if (pathEndId) cy.getElementById(pathEndId).removeClass('sp-end');
        // Clear any per-edge path direction/colour data
        cy.edges().forEach(e => { try { e.removeData('spDir'); e.removeData('spColor'); } catch {} });
        currentPathEles = null;
      }

      function isAnimate() {
        const el = document.getElementById("animate");
        return !el ? true : !!el.checked;
      }

      function showShortestPath() {
        if (!pathStartId || !pathEndId) return;
        const start = cy.getElementById(pathStartId);
        const end = cy.getElementById(pathEndId);
        if (start.empty() || end.empty()) {
          alert("Start or End node is not in the current graph.");
          return;
        }
        // Clear previous highlight
        clearShortestPath();
        // Use A* on current graph; treat as undirected for flexibility
        const result = cy.elements().aStar({ root: start, goal: end, directed: false });
        if (!result.found) {
          alert("No path found in current graph. Try expanding more.");
          return;
        }
        currentPathEles = result.path;
        // Mark start/end
        try { start.addClass('sp-start'); } catch {}
        try { end.addClass('sp-end'); } catch {}

        // Set direction attribute for each edge along the path based on start->end order
        const seq = currentPathEles.toArray();
        for (let i = 1; i < seq.length - 1; i++) {
          const ele = seq[i];
          if (!ele.isEdge()) continue;
          const prev = seq[i - 1];
          const next = seq[i + 1];
          if (!prev || !next || !prev.isNode() || !next.isNode()) continue;
          const src = ele.data('source');
          const tgt = ele.data('target');
          const forward = (src === prev.id() && tgt === next.id());
          try { ele.data('spDir', forward ? 'forward' : 'reverse'); } catch {}
        }

        if (isAnimate()) {
          const ordered = currentPathEles.toArray();
          // Bring edges forward in z-order a bit
          try { cy.edges().removeClass('sp'); } catch {}
          ordered.forEach((ele, idx) => {
            const t = setTimeout(() => { try { ele.addClass('sp'); } catch {} }, idx * 60);
            pathTimers.push(t);
          });
          const total = ordered.length * 60 + 100;
          pathTimers.push(setTimeout(() => {
            try { cy.animate({ fit: { eles: currentPathEles.union(start).union(end), padding: 40 }, duration: 400 }); } catch {}
            // start blinking after reveal
            startPathBlink();
          }, total));
        } else {
          currentPathEles.addClass("sp");
          cy.fit(currentPathEles.union(start).union(end), 40);
          // Do not blink when animate is off
        }

        // Refresh panel buttons state
        const sel = cy.nodes(":selected").first();
        if (sel && typeof sel.empty === 'function' && !sel.empty()) renderNodeDetails(sel.data());
      }

      function startPathBlink() {
        if (pathBlinkInterval) { try { clearInterval(pathBlinkInterval); } catch {} }
        const edges = currentPathEles ? currentPathEles.filter('edge') : cy.collection();
        if (!edges || edges.length === 0) return;
        // Initialize to A state
        try { edges.removeClass('sp-blinkB').addClass('sp-blinkA'); } catch {}
        let on = true;
        pathBlinkInterval = setInterval(() => {
          on = !on;
          try {
            if (on) { edges.removeClass('sp-blinkB').addClass('sp-blinkA'); }
            else { edges.removeClass('sp-blinkA').addClass('sp-blinkB'); }
          } catch {}
        }, 500);
      }
    </script>
  </body>
</html>
